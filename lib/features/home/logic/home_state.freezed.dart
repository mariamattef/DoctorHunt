// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'home_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$HomeState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() specializationLoading,
    required TResult Function(
            SpecializationsResponseModel specializationsResponseModel)
        specializationSucess,
    required TResult Function(ErrorHandler errorHandler) specializationerror,
    required TResult Function() allDoctorsLoading,
    required TResult Function(AllDoctorsResponseModel allDoctorsResponseModel)
        allDoctorsSuccess,
    required TResult Function(ErrorHandler errorHandler) allDoctorserror,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? specializationLoading,
    TResult? Function(
            SpecializationsResponseModel specializationsResponseModel)?
        specializationSucess,
    TResult? Function(ErrorHandler errorHandler)? specializationerror,
    TResult? Function()? allDoctorsLoading,
    TResult? Function(AllDoctorsResponseModel allDoctorsResponseModel)?
        allDoctorsSuccess,
    TResult? Function(ErrorHandler errorHandler)? allDoctorserror,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? specializationLoading,
    TResult Function(SpecializationsResponseModel specializationsResponseModel)?
        specializationSucess,
    TResult Function(ErrorHandler errorHandler)? specializationerror,
    TResult Function()? allDoctorsLoading,
    TResult Function(AllDoctorsResponseModel allDoctorsResponseModel)?
        allDoctorsSuccess,
    TResult Function(ErrorHandler errorHandler)? allDoctorserror,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(SpecializationLoading value)
        specializationLoading,
    required TResult Function(SpecializationSucess value) specializationSucess,
    required TResult Function(SpecializationError value) specializationerror,
    required TResult Function(AllDoctorsLoading value) allDoctorsLoading,
    required TResult Function(AllDoctorsSuccess value) allDoctorsSuccess,
    required TResult Function(AllDoctorsError value) allDoctorserror,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(SpecializationLoading value)? specializationLoading,
    TResult? Function(SpecializationSucess value)? specializationSucess,
    TResult? Function(SpecializationError value)? specializationerror,
    TResult? Function(AllDoctorsLoading value)? allDoctorsLoading,
    TResult? Function(AllDoctorsSuccess value)? allDoctorsSuccess,
    TResult? Function(AllDoctorsError value)? allDoctorserror,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(SpecializationLoading value)? specializationLoading,
    TResult Function(SpecializationSucess value)? specializationSucess,
    TResult Function(SpecializationError value)? specializationerror,
    TResult Function(AllDoctorsLoading value)? allDoctorsLoading,
    TResult Function(AllDoctorsSuccess value)? allDoctorsSuccess,
    TResult Function(AllDoctorsError value)? allDoctorserror,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $HomeStateCopyWith<$Res> {
  factory $HomeStateCopyWith(HomeState value, $Res Function(HomeState) then) =
      _$HomeStateCopyWithImpl<$Res, HomeState>;
}

/// @nodoc
class _$HomeStateCopyWithImpl<$Res, $Val extends HomeState>
    implements $HomeStateCopyWith<$Res> {
  _$HomeStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of HomeState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$InitialImplCopyWith<$Res> {
  factory _$$InitialImplCopyWith(
          _$InitialImpl value, $Res Function(_$InitialImpl) then) =
      __$$InitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitialImplCopyWithImpl<$Res>
    extends _$HomeStateCopyWithImpl<$Res, _$InitialImpl>
    implements _$$InitialImplCopyWith<$Res> {
  __$$InitialImplCopyWithImpl(
      _$InitialImpl _value, $Res Function(_$InitialImpl) _then)
      : super(_value, _then);

  /// Create a copy of HomeState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$InitialImpl implements _Initial {
  const _$InitialImpl();

  @override
  String toString() {
    return 'HomeState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() specializationLoading,
    required TResult Function(
            SpecializationsResponseModel specializationsResponseModel)
        specializationSucess,
    required TResult Function(ErrorHandler errorHandler) specializationerror,
    required TResult Function() allDoctorsLoading,
    required TResult Function(AllDoctorsResponseModel allDoctorsResponseModel)
        allDoctorsSuccess,
    required TResult Function(ErrorHandler errorHandler) allDoctorserror,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? specializationLoading,
    TResult? Function(
            SpecializationsResponseModel specializationsResponseModel)?
        specializationSucess,
    TResult? Function(ErrorHandler errorHandler)? specializationerror,
    TResult? Function()? allDoctorsLoading,
    TResult? Function(AllDoctorsResponseModel allDoctorsResponseModel)?
        allDoctorsSuccess,
    TResult? Function(ErrorHandler errorHandler)? allDoctorserror,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? specializationLoading,
    TResult Function(SpecializationsResponseModel specializationsResponseModel)?
        specializationSucess,
    TResult Function(ErrorHandler errorHandler)? specializationerror,
    TResult Function()? allDoctorsLoading,
    TResult Function(AllDoctorsResponseModel allDoctorsResponseModel)?
        allDoctorsSuccess,
    TResult Function(ErrorHandler errorHandler)? allDoctorserror,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(SpecializationLoading value)
        specializationLoading,
    required TResult Function(SpecializationSucess value) specializationSucess,
    required TResult Function(SpecializationError value) specializationerror,
    required TResult Function(AllDoctorsLoading value) allDoctorsLoading,
    required TResult Function(AllDoctorsSuccess value) allDoctorsSuccess,
    required TResult Function(AllDoctorsError value) allDoctorserror,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(SpecializationLoading value)? specializationLoading,
    TResult? Function(SpecializationSucess value)? specializationSucess,
    TResult? Function(SpecializationError value)? specializationerror,
    TResult? Function(AllDoctorsLoading value)? allDoctorsLoading,
    TResult? Function(AllDoctorsSuccess value)? allDoctorsSuccess,
    TResult? Function(AllDoctorsError value)? allDoctorserror,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(SpecializationLoading value)? specializationLoading,
    TResult Function(SpecializationSucess value)? specializationSucess,
    TResult Function(SpecializationError value)? specializationerror,
    TResult Function(AllDoctorsLoading value)? allDoctorsLoading,
    TResult Function(AllDoctorsSuccess value)? allDoctorsSuccess,
    TResult Function(AllDoctorsError value)? allDoctorserror,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial implements HomeState {
  const factory _Initial() = _$InitialImpl;
}

/// @nodoc
abstract class _$$SpecializationLoadingImplCopyWith<$Res> {
  factory _$$SpecializationLoadingImplCopyWith(
          _$SpecializationLoadingImpl value,
          $Res Function(_$SpecializationLoadingImpl) then) =
      __$$SpecializationLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SpecializationLoadingImplCopyWithImpl<$Res>
    extends _$HomeStateCopyWithImpl<$Res, _$SpecializationLoadingImpl>
    implements _$$SpecializationLoadingImplCopyWith<$Res> {
  __$$SpecializationLoadingImplCopyWithImpl(_$SpecializationLoadingImpl _value,
      $Res Function(_$SpecializationLoadingImpl) _then)
      : super(_value, _then);

  /// Create a copy of HomeState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$SpecializationLoadingImpl implements SpecializationLoading {
  const _$SpecializationLoadingImpl();

  @override
  String toString() {
    return 'HomeState.specializationLoading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SpecializationLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() specializationLoading,
    required TResult Function(
            SpecializationsResponseModel specializationsResponseModel)
        specializationSucess,
    required TResult Function(ErrorHandler errorHandler) specializationerror,
    required TResult Function() allDoctorsLoading,
    required TResult Function(AllDoctorsResponseModel allDoctorsResponseModel)
        allDoctorsSuccess,
    required TResult Function(ErrorHandler errorHandler) allDoctorserror,
  }) {
    return specializationLoading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? specializationLoading,
    TResult? Function(
            SpecializationsResponseModel specializationsResponseModel)?
        specializationSucess,
    TResult? Function(ErrorHandler errorHandler)? specializationerror,
    TResult? Function()? allDoctorsLoading,
    TResult? Function(AllDoctorsResponseModel allDoctorsResponseModel)?
        allDoctorsSuccess,
    TResult? Function(ErrorHandler errorHandler)? allDoctorserror,
  }) {
    return specializationLoading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? specializationLoading,
    TResult Function(SpecializationsResponseModel specializationsResponseModel)?
        specializationSucess,
    TResult Function(ErrorHandler errorHandler)? specializationerror,
    TResult Function()? allDoctorsLoading,
    TResult Function(AllDoctorsResponseModel allDoctorsResponseModel)?
        allDoctorsSuccess,
    TResult Function(ErrorHandler errorHandler)? allDoctorserror,
    required TResult orElse(),
  }) {
    if (specializationLoading != null) {
      return specializationLoading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(SpecializationLoading value)
        specializationLoading,
    required TResult Function(SpecializationSucess value) specializationSucess,
    required TResult Function(SpecializationError value) specializationerror,
    required TResult Function(AllDoctorsLoading value) allDoctorsLoading,
    required TResult Function(AllDoctorsSuccess value) allDoctorsSuccess,
    required TResult Function(AllDoctorsError value) allDoctorserror,
  }) {
    return specializationLoading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(SpecializationLoading value)? specializationLoading,
    TResult? Function(SpecializationSucess value)? specializationSucess,
    TResult? Function(SpecializationError value)? specializationerror,
    TResult? Function(AllDoctorsLoading value)? allDoctorsLoading,
    TResult? Function(AllDoctorsSuccess value)? allDoctorsSuccess,
    TResult? Function(AllDoctorsError value)? allDoctorserror,
  }) {
    return specializationLoading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(SpecializationLoading value)? specializationLoading,
    TResult Function(SpecializationSucess value)? specializationSucess,
    TResult Function(SpecializationError value)? specializationerror,
    TResult Function(AllDoctorsLoading value)? allDoctorsLoading,
    TResult Function(AllDoctorsSuccess value)? allDoctorsSuccess,
    TResult Function(AllDoctorsError value)? allDoctorserror,
    required TResult orElse(),
  }) {
    if (specializationLoading != null) {
      return specializationLoading(this);
    }
    return orElse();
  }
}

abstract class SpecializationLoading implements HomeState {
  const factory SpecializationLoading() = _$SpecializationLoadingImpl;
}

/// @nodoc
abstract class _$$SpecializationSucessImplCopyWith<$Res> {
  factory _$$SpecializationSucessImplCopyWith(_$SpecializationSucessImpl value,
          $Res Function(_$SpecializationSucessImpl) then) =
      __$$SpecializationSucessImplCopyWithImpl<$Res>;
  @useResult
  $Res call({SpecializationsResponseModel specializationsResponseModel});
}

/// @nodoc
class __$$SpecializationSucessImplCopyWithImpl<$Res>
    extends _$HomeStateCopyWithImpl<$Res, _$SpecializationSucessImpl>
    implements _$$SpecializationSucessImplCopyWith<$Res> {
  __$$SpecializationSucessImplCopyWithImpl(_$SpecializationSucessImpl _value,
      $Res Function(_$SpecializationSucessImpl) _then)
      : super(_value, _then);

  /// Create a copy of HomeState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? specializationsResponseModel = null,
  }) {
    return _then(_$SpecializationSucessImpl(
      null == specializationsResponseModel
          ? _value.specializationsResponseModel
          : specializationsResponseModel // ignore: cast_nullable_to_non_nullable
              as SpecializationsResponseModel,
    ));
  }
}

/// @nodoc

class _$SpecializationSucessImpl implements SpecializationSucess {
  const _$SpecializationSucessImpl(this.specializationsResponseModel);

  @override
  final SpecializationsResponseModel specializationsResponseModel;

  @override
  String toString() {
    return 'HomeState.specializationSucess(specializationsResponseModel: $specializationsResponseModel)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SpecializationSucessImpl &&
            (identical(other.specializationsResponseModel,
                    specializationsResponseModel) ||
                other.specializationsResponseModel ==
                    specializationsResponseModel));
  }

  @override
  int get hashCode => Object.hash(runtimeType, specializationsResponseModel);

  /// Create a copy of HomeState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SpecializationSucessImplCopyWith<_$SpecializationSucessImpl>
      get copyWith =>
          __$$SpecializationSucessImplCopyWithImpl<_$SpecializationSucessImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() specializationLoading,
    required TResult Function(
            SpecializationsResponseModel specializationsResponseModel)
        specializationSucess,
    required TResult Function(ErrorHandler errorHandler) specializationerror,
    required TResult Function() allDoctorsLoading,
    required TResult Function(AllDoctorsResponseModel allDoctorsResponseModel)
        allDoctorsSuccess,
    required TResult Function(ErrorHandler errorHandler) allDoctorserror,
  }) {
    return specializationSucess(specializationsResponseModel);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? specializationLoading,
    TResult? Function(
            SpecializationsResponseModel specializationsResponseModel)?
        specializationSucess,
    TResult? Function(ErrorHandler errorHandler)? specializationerror,
    TResult? Function()? allDoctorsLoading,
    TResult? Function(AllDoctorsResponseModel allDoctorsResponseModel)?
        allDoctorsSuccess,
    TResult? Function(ErrorHandler errorHandler)? allDoctorserror,
  }) {
    return specializationSucess?.call(specializationsResponseModel);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? specializationLoading,
    TResult Function(SpecializationsResponseModel specializationsResponseModel)?
        specializationSucess,
    TResult Function(ErrorHandler errorHandler)? specializationerror,
    TResult Function()? allDoctorsLoading,
    TResult Function(AllDoctorsResponseModel allDoctorsResponseModel)?
        allDoctorsSuccess,
    TResult Function(ErrorHandler errorHandler)? allDoctorserror,
    required TResult orElse(),
  }) {
    if (specializationSucess != null) {
      return specializationSucess(specializationsResponseModel);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(SpecializationLoading value)
        specializationLoading,
    required TResult Function(SpecializationSucess value) specializationSucess,
    required TResult Function(SpecializationError value) specializationerror,
    required TResult Function(AllDoctorsLoading value) allDoctorsLoading,
    required TResult Function(AllDoctorsSuccess value) allDoctorsSuccess,
    required TResult Function(AllDoctorsError value) allDoctorserror,
  }) {
    return specializationSucess(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(SpecializationLoading value)? specializationLoading,
    TResult? Function(SpecializationSucess value)? specializationSucess,
    TResult? Function(SpecializationError value)? specializationerror,
    TResult? Function(AllDoctorsLoading value)? allDoctorsLoading,
    TResult? Function(AllDoctorsSuccess value)? allDoctorsSuccess,
    TResult? Function(AllDoctorsError value)? allDoctorserror,
  }) {
    return specializationSucess?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(SpecializationLoading value)? specializationLoading,
    TResult Function(SpecializationSucess value)? specializationSucess,
    TResult Function(SpecializationError value)? specializationerror,
    TResult Function(AllDoctorsLoading value)? allDoctorsLoading,
    TResult Function(AllDoctorsSuccess value)? allDoctorsSuccess,
    TResult Function(AllDoctorsError value)? allDoctorserror,
    required TResult orElse(),
  }) {
    if (specializationSucess != null) {
      return specializationSucess(this);
    }
    return orElse();
  }
}

abstract class SpecializationSucess implements HomeState {
  const factory SpecializationSucess(
          final SpecializationsResponseModel specializationsResponseModel) =
      _$SpecializationSucessImpl;

  SpecializationsResponseModel get specializationsResponseModel;

  /// Create a copy of HomeState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SpecializationSucessImplCopyWith<_$SpecializationSucessImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SpecializationErrorImplCopyWith<$Res> {
  factory _$$SpecializationErrorImplCopyWith(_$SpecializationErrorImpl value,
          $Res Function(_$SpecializationErrorImpl) then) =
      __$$SpecializationErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({ErrorHandler errorHandler});
}

/// @nodoc
class __$$SpecializationErrorImplCopyWithImpl<$Res>
    extends _$HomeStateCopyWithImpl<$Res, _$SpecializationErrorImpl>
    implements _$$SpecializationErrorImplCopyWith<$Res> {
  __$$SpecializationErrorImplCopyWithImpl(_$SpecializationErrorImpl _value,
      $Res Function(_$SpecializationErrorImpl) _then)
      : super(_value, _then);

  /// Create a copy of HomeState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorHandler = null,
  }) {
    return _then(_$SpecializationErrorImpl(
      null == errorHandler
          ? _value.errorHandler
          : errorHandler // ignore: cast_nullable_to_non_nullable
              as ErrorHandler,
    ));
  }
}

/// @nodoc

class _$SpecializationErrorImpl implements SpecializationError {
  const _$SpecializationErrorImpl(this.errorHandler);

  @override
  final ErrorHandler errorHandler;

  @override
  String toString() {
    return 'HomeState.specializationerror(errorHandler: $errorHandler)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SpecializationErrorImpl &&
            (identical(other.errorHandler, errorHandler) ||
                other.errorHandler == errorHandler));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorHandler);

  /// Create a copy of HomeState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SpecializationErrorImplCopyWith<_$SpecializationErrorImpl> get copyWith =>
      __$$SpecializationErrorImplCopyWithImpl<_$SpecializationErrorImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() specializationLoading,
    required TResult Function(
            SpecializationsResponseModel specializationsResponseModel)
        specializationSucess,
    required TResult Function(ErrorHandler errorHandler) specializationerror,
    required TResult Function() allDoctorsLoading,
    required TResult Function(AllDoctorsResponseModel allDoctorsResponseModel)
        allDoctorsSuccess,
    required TResult Function(ErrorHandler errorHandler) allDoctorserror,
  }) {
    return specializationerror(errorHandler);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? specializationLoading,
    TResult? Function(
            SpecializationsResponseModel specializationsResponseModel)?
        specializationSucess,
    TResult? Function(ErrorHandler errorHandler)? specializationerror,
    TResult? Function()? allDoctorsLoading,
    TResult? Function(AllDoctorsResponseModel allDoctorsResponseModel)?
        allDoctorsSuccess,
    TResult? Function(ErrorHandler errorHandler)? allDoctorserror,
  }) {
    return specializationerror?.call(errorHandler);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? specializationLoading,
    TResult Function(SpecializationsResponseModel specializationsResponseModel)?
        specializationSucess,
    TResult Function(ErrorHandler errorHandler)? specializationerror,
    TResult Function()? allDoctorsLoading,
    TResult Function(AllDoctorsResponseModel allDoctorsResponseModel)?
        allDoctorsSuccess,
    TResult Function(ErrorHandler errorHandler)? allDoctorserror,
    required TResult orElse(),
  }) {
    if (specializationerror != null) {
      return specializationerror(errorHandler);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(SpecializationLoading value)
        specializationLoading,
    required TResult Function(SpecializationSucess value) specializationSucess,
    required TResult Function(SpecializationError value) specializationerror,
    required TResult Function(AllDoctorsLoading value) allDoctorsLoading,
    required TResult Function(AllDoctorsSuccess value) allDoctorsSuccess,
    required TResult Function(AllDoctorsError value) allDoctorserror,
  }) {
    return specializationerror(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(SpecializationLoading value)? specializationLoading,
    TResult? Function(SpecializationSucess value)? specializationSucess,
    TResult? Function(SpecializationError value)? specializationerror,
    TResult? Function(AllDoctorsLoading value)? allDoctorsLoading,
    TResult? Function(AllDoctorsSuccess value)? allDoctorsSuccess,
    TResult? Function(AllDoctorsError value)? allDoctorserror,
  }) {
    return specializationerror?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(SpecializationLoading value)? specializationLoading,
    TResult Function(SpecializationSucess value)? specializationSucess,
    TResult Function(SpecializationError value)? specializationerror,
    TResult Function(AllDoctorsLoading value)? allDoctorsLoading,
    TResult Function(AllDoctorsSuccess value)? allDoctorsSuccess,
    TResult Function(AllDoctorsError value)? allDoctorserror,
    required TResult orElse(),
  }) {
    if (specializationerror != null) {
      return specializationerror(this);
    }
    return orElse();
  }
}

abstract class SpecializationError implements HomeState {
  const factory SpecializationError(final ErrorHandler errorHandler) =
      _$SpecializationErrorImpl;

  ErrorHandler get errorHandler;

  /// Create a copy of HomeState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SpecializationErrorImplCopyWith<_$SpecializationErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AllDoctorsLoadingImplCopyWith<$Res> {
  factory _$$AllDoctorsLoadingImplCopyWith(_$AllDoctorsLoadingImpl value,
          $Res Function(_$AllDoctorsLoadingImpl) then) =
      __$$AllDoctorsLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AllDoctorsLoadingImplCopyWithImpl<$Res>
    extends _$HomeStateCopyWithImpl<$Res, _$AllDoctorsLoadingImpl>
    implements _$$AllDoctorsLoadingImplCopyWith<$Res> {
  __$$AllDoctorsLoadingImplCopyWithImpl(_$AllDoctorsLoadingImpl _value,
      $Res Function(_$AllDoctorsLoadingImpl) _then)
      : super(_value, _then);

  /// Create a copy of HomeState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$AllDoctorsLoadingImpl implements AllDoctorsLoading {
  const _$AllDoctorsLoadingImpl();

  @override
  String toString() {
    return 'HomeState.allDoctorsLoading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$AllDoctorsLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() specializationLoading,
    required TResult Function(
            SpecializationsResponseModel specializationsResponseModel)
        specializationSucess,
    required TResult Function(ErrorHandler errorHandler) specializationerror,
    required TResult Function() allDoctorsLoading,
    required TResult Function(AllDoctorsResponseModel allDoctorsResponseModel)
        allDoctorsSuccess,
    required TResult Function(ErrorHandler errorHandler) allDoctorserror,
  }) {
    return allDoctorsLoading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? specializationLoading,
    TResult? Function(
            SpecializationsResponseModel specializationsResponseModel)?
        specializationSucess,
    TResult? Function(ErrorHandler errorHandler)? specializationerror,
    TResult? Function()? allDoctorsLoading,
    TResult? Function(AllDoctorsResponseModel allDoctorsResponseModel)?
        allDoctorsSuccess,
    TResult? Function(ErrorHandler errorHandler)? allDoctorserror,
  }) {
    return allDoctorsLoading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? specializationLoading,
    TResult Function(SpecializationsResponseModel specializationsResponseModel)?
        specializationSucess,
    TResult Function(ErrorHandler errorHandler)? specializationerror,
    TResult Function()? allDoctorsLoading,
    TResult Function(AllDoctorsResponseModel allDoctorsResponseModel)?
        allDoctorsSuccess,
    TResult Function(ErrorHandler errorHandler)? allDoctorserror,
    required TResult orElse(),
  }) {
    if (allDoctorsLoading != null) {
      return allDoctorsLoading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(SpecializationLoading value)
        specializationLoading,
    required TResult Function(SpecializationSucess value) specializationSucess,
    required TResult Function(SpecializationError value) specializationerror,
    required TResult Function(AllDoctorsLoading value) allDoctorsLoading,
    required TResult Function(AllDoctorsSuccess value) allDoctorsSuccess,
    required TResult Function(AllDoctorsError value) allDoctorserror,
  }) {
    return allDoctorsLoading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(SpecializationLoading value)? specializationLoading,
    TResult? Function(SpecializationSucess value)? specializationSucess,
    TResult? Function(SpecializationError value)? specializationerror,
    TResult? Function(AllDoctorsLoading value)? allDoctorsLoading,
    TResult? Function(AllDoctorsSuccess value)? allDoctorsSuccess,
    TResult? Function(AllDoctorsError value)? allDoctorserror,
  }) {
    return allDoctorsLoading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(SpecializationLoading value)? specializationLoading,
    TResult Function(SpecializationSucess value)? specializationSucess,
    TResult Function(SpecializationError value)? specializationerror,
    TResult Function(AllDoctorsLoading value)? allDoctorsLoading,
    TResult Function(AllDoctorsSuccess value)? allDoctorsSuccess,
    TResult Function(AllDoctorsError value)? allDoctorserror,
    required TResult orElse(),
  }) {
    if (allDoctorsLoading != null) {
      return allDoctorsLoading(this);
    }
    return orElse();
  }
}

abstract class AllDoctorsLoading implements HomeState {
  const factory AllDoctorsLoading() = _$AllDoctorsLoadingImpl;
}

/// @nodoc
abstract class _$$AllDoctorsSuccessImplCopyWith<$Res> {
  factory _$$AllDoctorsSuccessImplCopyWith(_$AllDoctorsSuccessImpl value,
          $Res Function(_$AllDoctorsSuccessImpl) then) =
      __$$AllDoctorsSuccessImplCopyWithImpl<$Res>;
  @useResult
  $Res call({AllDoctorsResponseModel allDoctorsResponseModel});
}

/// @nodoc
class __$$AllDoctorsSuccessImplCopyWithImpl<$Res>
    extends _$HomeStateCopyWithImpl<$Res, _$AllDoctorsSuccessImpl>
    implements _$$AllDoctorsSuccessImplCopyWith<$Res> {
  __$$AllDoctorsSuccessImplCopyWithImpl(_$AllDoctorsSuccessImpl _value,
      $Res Function(_$AllDoctorsSuccessImpl) _then)
      : super(_value, _then);

  /// Create a copy of HomeState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? allDoctorsResponseModel = freezed,
  }) {
    return _then(_$AllDoctorsSuccessImpl(
      freezed == allDoctorsResponseModel
          ? _value.allDoctorsResponseModel
          : allDoctorsResponseModel // ignore: cast_nullable_to_non_nullable
              as AllDoctorsResponseModel,
    ));
  }
}

/// @nodoc

class _$AllDoctorsSuccessImpl implements AllDoctorsSuccess {
  const _$AllDoctorsSuccessImpl(this.allDoctorsResponseModel);

  @override
  final AllDoctorsResponseModel allDoctorsResponseModel;

  @override
  String toString() {
    return 'HomeState.allDoctorsSuccess(allDoctorsResponseModel: $allDoctorsResponseModel)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AllDoctorsSuccessImpl &&
            const DeepCollectionEquality().equals(
                other.allDoctorsResponseModel, allDoctorsResponseModel));
  }

  @override
  int get hashCode => Object.hash(runtimeType,
      const DeepCollectionEquality().hash(allDoctorsResponseModel));

  /// Create a copy of HomeState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AllDoctorsSuccessImplCopyWith<_$AllDoctorsSuccessImpl> get copyWith =>
      __$$AllDoctorsSuccessImplCopyWithImpl<_$AllDoctorsSuccessImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() specializationLoading,
    required TResult Function(
            SpecializationsResponseModel specializationsResponseModel)
        specializationSucess,
    required TResult Function(ErrorHandler errorHandler) specializationerror,
    required TResult Function() allDoctorsLoading,
    required TResult Function(AllDoctorsResponseModel allDoctorsResponseModel)
        allDoctorsSuccess,
    required TResult Function(ErrorHandler errorHandler) allDoctorserror,
  }) {
    return allDoctorsSuccess(allDoctorsResponseModel);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? specializationLoading,
    TResult? Function(
            SpecializationsResponseModel specializationsResponseModel)?
        specializationSucess,
    TResult? Function(ErrorHandler errorHandler)? specializationerror,
    TResult? Function()? allDoctorsLoading,
    TResult? Function(AllDoctorsResponseModel allDoctorsResponseModel)?
        allDoctorsSuccess,
    TResult? Function(ErrorHandler errorHandler)? allDoctorserror,
  }) {
    return allDoctorsSuccess?.call(allDoctorsResponseModel);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? specializationLoading,
    TResult Function(SpecializationsResponseModel specializationsResponseModel)?
        specializationSucess,
    TResult Function(ErrorHandler errorHandler)? specializationerror,
    TResult Function()? allDoctorsLoading,
    TResult Function(AllDoctorsResponseModel allDoctorsResponseModel)?
        allDoctorsSuccess,
    TResult Function(ErrorHandler errorHandler)? allDoctorserror,
    required TResult orElse(),
  }) {
    if (allDoctorsSuccess != null) {
      return allDoctorsSuccess(allDoctorsResponseModel);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(SpecializationLoading value)
        specializationLoading,
    required TResult Function(SpecializationSucess value) specializationSucess,
    required TResult Function(SpecializationError value) specializationerror,
    required TResult Function(AllDoctorsLoading value) allDoctorsLoading,
    required TResult Function(AllDoctorsSuccess value) allDoctorsSuccess,
    required TResult Function(AllDoctorsError value) allDoctorserror,
  }) {
    return allDoctorsSuccess(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(SpecializationLoading value)? specializationLoading,
    TResult? Function(SpecializationSucess value)? specializationSucess,
    TResult? Function(SpecializationError value)? specializationerror,
    TResult? Function(AllDoctorsLoading value)? allDoctorsLoading,
    TResult? Function(AllDoctorsSuccess value)? allDoctorsSuccess,
    TResult? Function(AllDoctorsError value)? allDoctorserror,
  }) {
    return allDoctorsSuccess?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(SpecializationLoading value)? specializationLoading,
    TResult Function(SpecializationSucess value)? specializationSucess,
    TResult Function(SpecializationError value)? specializationerror,
    TResult Function(AllDoctorsLoading value)? allDoctorsLoading,
    TResult Function(AllDoctorsSuccess value)? allDoctorsSuccess,
    TResult Function(AllDoctorsError value)? allDoctorserror,
    required TResult orElse(),
  }) {
    if (allDoctorsSuccess != null) {
      return allDoctorsSuccess(this);
    }
    return orElse();
  }
}

abstract class AllDoctorsSuccess implements HomeState {
  const factory AllDoctorsSuccess(
          final AllDoctorsResponseModel allDoctorsResponseModel) =
      _$AllDoctorsSuccessImpl;

  AllDoctorsResponseModel get allDoctorsResponseModel;

  /// Create a copy of HomeState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AllDoctorsSuccessImplCopyWith<_$AllDoctorsSuccessImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AllDoctorsErrorImplCopyWith<$Res> {
  factory _$$AllDoctorsErrorImplCopyWith(_$AllDoctorsErrorImpl value,
          $Res Function(_$AllDoctorsErrorImpl) then) =
      __$$AllDoctorsErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({ErrorHandler errorHandler});
}

/// @nodoc
class __$$AllDoctorsErrorImplCopyWithImpl<$Res>
    extends _$HomeStateCopyWithImpl<$Res, _$AllDoctorsErrorImpl>
    implements _$$AllDoctorsErrorImplCopyWith<$Res> {
  __$$AllDoctorsErrorImplCopyWithImpl(
      _$AllDoctorsErrorImpl _value, $Res Function(_$AllDoctorsErrorImpl) _then)
      : super(_value, _then);

  /// Create a copy of HomeState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorHandler = null,
  }) {
    return _then(_$AllDoctorsErrorImpl(
      null == errorHandler
          ? _value.errorHandler
          : errorHandler // ignore: cast_nullable_to_non_nullable
              as ErrorHandler,
    ));
  }
}

/// @nodoc

class _$AllDoctorsErrorImpl implements AllDoctorsError {
  const _$AllDoctorsErrorImpl(this.errorHandler);

  @override
  final ErrorHandler errorHandler;

  @override
  String toString() {
    return 'HomeState.allDoctorserror(errorHandler: $errorHandler)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AllDoctorsErrorImpl &&
            (identical(other.errorHandler, errorHandler) ||
                other.errorHandler == errorHandler));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorHandler);

  /// Create a copy of HomeState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AllDoctorsErrorImplCopyWith<_$AllDoctorsErrorImpl> get copyWith =>
      __$$AllDoctorsErrorImplCopyWithImpl<_$AllDoctorsErrorImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() specializationLoading,
    required TResult Function(
            SpecializationsResponseModel specializationsResponseModel)
        specializationSucess,
    required TResult Function(ErrorHandler errorHandler) specializationerror,
    required TResult Function() allDoctorsLoading,
    required TResult Function(AllDoctorsResponseModel allDoctorsResponseModel)
        allDoctorsSuccess,
    required TResult Function(ErrorHandler errorHandler) allDoctorserror,
  }) {
    return allDoctorserror(errorHandler);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? specializationLoading,
    TResult? Function(
            SpecializationsResponseModel specializationsResponseModel)?
        specializationSucess,
    TResult? Function(ErrorHandler errorHandler)? specializationerror,
    TResult? Function()? allDoctorsLoading,
    TResult? Function(AllDoctorsResponseModel allDoctorsResponseModel)?
        allDoctorsSuccess,
    TResult? Function(ErrorHandler errorHandler)? allDoctorserror,
  }) {
    return allDoctorserror?.call(errorHandler);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? specializationLoading,
    TResult Function(SpecializationsResponseModel specializationsResponseModel)?
        specializationSucess,
    TResult Function(ErrorHandler errorHandler)? specializationerror,
    TResult Function()? allDoctorsLoading,
    TResult Function(AllDoctorsResponseModel allDoctorsResponseModel)?
        allDoctorsSuccess,
    TResult Function(ErrorHandler errorHandler)? allDoctorserror,
    required TResult orElse(),
  }) {
    if (allDoctorserror != null) {
      return allDoctorserror(errorHandler);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(SpecializationLoading value)
        specializationLoading,
    required TResult Function(SpecializationSucess value) specializationSucess,
    required TResult Function(SpecializationError value) specializationerror,
    required TResult Function(AllDoctorsLoading value) allDoctorsLoading,
    required TResult Function(AllDoctorsSuccess value) allDoctorsSuccess,
    required TResult Function(AllDoctorsError value) allDoctorserror,
  }) {
    return allDoctorserror(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(SpecializationLoading value)? specializationLoading,
    TResult? Function(SpecializationSucess value)? specializationSucess,
    TResult? Function(SpecializationError value)? specializationerror,
    TResult? Function(AllDoctorsLoading value)? allDoctorsLoading,
    TResult? Function(AllDoctorsSuccess value)? allDoctorsSuccess,
    TResult? Function(AllDoctorsError value)? allDoctorserror,
  }) {
    return allDoctorserror?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(SpecializationLoading value)? specializationLoading,
    TResult Function(SpecializationSucess value)? specializationSucess,
    TResult Function(SpecializationError value)? specializationerror,
    TResult Function(AllDoctorsLoading value)? allDoctorsLoading,
    TResult Function(AllDoctorsSuccess value)? allDoctorsSuccess,
    TResult Function(AllDoctorsError value)? allDoctorserror,
    required TResult orElse(),
  }) {
    if (allDoctorserror != null) {
      return allDoctorserror(this);
    }
    return orElse();
  }
}

abstract class AllDoctorsError implements HomeState {
  const factory AllDoctorsError(final ErrorHandler errorHandler) =
      _$AllDoctorsErrorImpl;

  ErrorHandler get errorHandler;

  /// Create a copy of HomeState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AllDoctorsErrorImplCopyWith<_$AllDoctorsErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
